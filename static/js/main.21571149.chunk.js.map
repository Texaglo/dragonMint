{"version":3,"sources":["CandyMachine/index.js","CandyMachine/connection.js","assets/twitter-logo.svg","App.js","index.js","CandyMachine/helpers.js"],"names":["SystemProgram","web3","opts","CandyMachine","walletAddress","useState","candyMachine","setCandyMachine","useEffect","getCandyMachineState","a","provider","getProvider","Program","fetchIdl","candyMachineProgram","idl","program","account","fetch","process","itemsAvailable","data","toNumber","itemsRedeemed","itemsRemaining","goLiveData","goLiveDate","presale","whitelistMintSettings","Date","getTime","goLiveDateTimeString","toGMTString","id","state","isSoldOut","isActive","endSettings","endSettingType","date","number","isPresale","treasury","wallet","tokenMint","gatekeeper","hiddenSettings","price","console","log","connection","Connection","Provider","window","solana","getCandyMachineCreator","candyMachineID","PublicKey","findProgramAddress","Buffer","from","toBuffer","getMetadata","mint","TOKEN_METADATA_PROGRAM_ID","getMasterEdition","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","splTokenMintAddress","keys","pubkey","isSigner","isWritable","programId","TOKEN_PROGRAM_ID","SYSVAR_RENT_PUBKEY","TransactionInstruction","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","mintToken","Keypair","generate","getAtaForMint","publicKey","userTokenAccountAddress","userPayingAccountAddress","candyMachineAddress","remainingAccounts","signers","cleanupInstructions","MintLayout","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","instructions","getNetworkToken","gatekeeperNetwork","push","expireOnUse","CIVIC","getNetworkExpire","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","undefined","sendTransactions","txs","map","t","txid","className","onClick","then","alert","instructionSet","signersSet","sequenceType","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","transaction","Transaction","forEach","add","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","catch","reason","Promise","all","getUnixTs","DEFAULT_TIMEOUT","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","App","setWalletAddress","checkIfWalletIsConnected","isPhantom","connect","onlyIfTrusted","response","connectWallet","onLoad","addEventListener","removeEventListener","ReactDOM","render","StrictMode","document","getElementById","anchor","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","buyer"],"mappings":"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","file":"static/js/main.21571149.chunk.js","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport { Program, Provider, web3 } from \"@project-serum/anchor\";\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { sendTransactions } from \"./connection\";\nimport \"./CandyMachine.css\";\nimport {\n\tcandyMachineProgram,\n\tTOKEN_METADATA_PROGRAM_ID,\n\tSPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n\tgetAtaForMint,\n\tgetNetworkExpire,\n\tgetNetworkToken,\n\tCIVIC,\n} from \"./helpers\";\n\nconst { SystemProgram } = web3;\nconst opts = {\n\tpreflightCommitment: \"processed\",\n};\n\nconst CandyMachine = ({ walletAddress }) => {\n\tconst [candyMachine, setCandyMachine] = useState(null);\n\tuseEffect(() => {\n\t\tgetCandyMachineState();\n\t}, []);\n\tconst getCandyMachineState = async () => {\n\t\tconst provider = getProvider();\n\n\t\tconst idl = await Program.fetchIdl(candyMachineProgram, provider);\n\n\t\tconst program = new Program(idl, candyMachineProgram, provider);\n\n\t\tconst candyMachine = await program.account.candyMachine.fetch(\n\t\t\tprocess.env.REACT_APP_CANDY_MACHINE_ID\n\t\t);\n\n\t\tconst itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\n\t\tconst itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\n\t\tconst itemsRemaining = itemsAvailable - itemsRedeemed;\n\t\tconst goLiveData = candyMachine.data.goLiveDate.toNumber();\n\t\tconst presale =\n\t\t\tcandyMachine.data.whitelistMintSettings &&\n\t\t\tcandyMachine.data.whitelistMintSettings.presale &&\n\t\t\t(!candyMachine.data.goLiveDate ||\n\t\t\t\tcandyMachine.data.goLiveDate.toNumber() >\n\t\t\t\t\tnew Date().getTime() / 1000);\n\n\t\tconst goLiveDateTimeString = `${new Date(\n\t\t\tgoLiveData * 1000\n\t\t).toGMTString()}`;\n\n\t\tsetCandyMachine({\n\t\t\tid: process.env.REACT_APP_CANDY_MACHINE_ID,\n\t\t\tprogram,\n\t\t\tstate: {\n\t\t\t\titemsAvailable,\n\t\t\t\titemsRedeemed,\n\t\t\t\titemsRemaining,\n\t\t\t\tgoLiveData,\n\t\t\t\tgoLiveDateTimeString,\n\t\t\t\tisSoldOut: itemsRemaining === 0,\n\t\t\t\tisActive:\n\t\t\t\t\t(presale ||\n\t\t\t\t\t\tcandyMachine.data.goLiveDate.toNumber() <\n\t\t\t\t\t\t\tnew Date().getTime() / 1000) &&\n\t\t\t\t\t(candyMachine.endSettings\n\t\t\t\t\t\t? candyMachine.endSettings.endSettingType.date\n\t\t\t\t\t\t\t? candyMachine.endSettings.number.toNumber() >\n\t\t\t\t\t\t\t  new Date().getTime() / 1000\n\t\t\t\t\t\t\t: itemsRedeemed <\n\t\t\t\t\t\t\t  candyMachine.endSettings.number.toNumber()\n\t\t\t\t\t\t: true),\n\t\t\t\tisPresale: presale,\n\t\t\t\tgoLiveDate: candyMachine.data.goLiveDate,\n\t\t\t\ttreasury: candyMachine.wallet,\n\t\t\t\ttokenMint: candyMachine.tokenMint,\n\t\t\t\tgatekeeper: candyMachine.data.gatekeeper,\n\t\t\t\tendSettings: candyMachine.data.endSettings,\n\t\t\t\twhitelistMintSettings: candyMachine.data.whitelistMintSettings,\n\t\t\t\thiddenSettings: candyMachine.data.hiddenSettings,\n\t\t\t\tprice: candyMachine.data.price,\n\t\t\t},\n\t\t});\n\n\t\tconsole.log({\n\t\t\titemsAvailable,\n\t\t\titemsRedeemed,\n\t\t\titemsRemaining,\n\t\t\tgoLiveData,\n\t\t\tgoLiveDateTimeString,\n\t\t});\n\t};\n\tconst getProvider = () => {\n\t\tconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\n\t\tconst connection = new Connection(rpcHost);\n\t\tconst provider = new Provider(\n\t\t\tconnection,\n\t\t\twindow.solana,\n\t\t\topts.preflightCommitment\n\t\t);\n\n\t\treturn provider;\n\t};\n\tconst getCandyMachineCreator = async (candyMachine) => {\n\t\tconst candyMachineID = new PublicKey(candyMachine);\n\t\treturn await web3.PublicKey.findProgramAddress(\n\t\t\t[Buffer.from(\"candy_machine\"), candyMachineID.toBuffer()],\n\t\t\tcandyMachineProgram\n\t\t);\n\t};\n\n\tconst getMetadata = async (mint) => {\n\t\treturn (\n\t\t\tawait PublicKey.findProgramAddress(\n\t\t\t\t[\n\t\t\t\t\tBuffer.from(\"metadata\"),\n\t\t\t\t\tTOKEN_METADATA_PROGRAM_ID.toBuffer(),\n\t\t\t\t\tmint.toBuffer(),\n\t\t\t\t],\n\t\t\t\tTOKEN_METADATA_PROGRAM_ID\n\t\t\t)\n\t\t)[0];\n\t};\n\n\tconst getMasterEdition = async (mint) => {\n\t\treturn (\n\t\t\tawait PublicKey.findProgramAddress(\n\t\t\t\t[\n\t\t\t\t\tBuffer.from(\"metadata\"),\n\t\t\t\t\tTOKEN_METADATA_PROGRAM_ID.toBuffer(),\n\t\t\t\t\tmint.toBuffer(),\n\t\t\t\t\tBuffer.from(\"edition\"),\n\t\t\t\t],\n\t\t\t\tTOKEN_METADATA_PROGRAM_ID\n\t\t\t)\n\t\t)[0];\n\t};\n\n\tconst createAssociatedTokenAccountInstruction = (\n\t\tassociatedTokenAddress,\n\t\tpayer,\n\t\twalletAddress,\n\t\tsplTokenMintAddress\n\t) => {\n\t\tconst keys = [\n\t\t\t{ pubkey: payer, isSigner: true, isWritable: true },\n\t\t\t{\n\t\t\t\tpubkey: associatedTokenAddress,\n\t\t\t\tisSigner: false,\n\t\t\t\tisWritable: true,\n\t\t\t},\n\t\t\t{ pubkey: walletAddress, isSigner: false, isWritable: false },\n\t\t\t{ pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n\t\t\t{\n\t\t\t\tpubkey: web3.SystemProgram.programId,\n\t\t\t\tisSigner: false,\n\t\t\t\tisWritable: false,\n\t\t\t},\n\t\t\t{ pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n\t\t\t{\n\t\t\t\tpubkey: web3.SYSVAR_RENT_PUBKEY,\n\t\t\t\tisSigner: false,\n\t\t\t\tisWritable: false,\n\t\t\t},\n\t\t];\n\t\treturn new web3.TransactionInstruction({\n\t\t\tkeys,\n\t\t\tprogramId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n\t\t\tdata: Buffer.from([]),\n\t\t});\n\t};\n\n\tconst mintToken = async () => {\n\t\tconst mint = web3.Keypair.generate();\n\n\t\tconst userTokenAccountAddress = (\n\t\t\tawait getAtaForMint(mint.publicKey, walletAddress.publicKey)\n\t\t)[0];\n\n\t\tconst userPayingAccountAddress = candyMachine.state.tokenMint\n\t\t\t? (\n\t\t\t\t\tawait getAtaForMint(\n\t\t\t\t\t\tcandyMachine.state.tokenMint,\n\t\t\t\t\t\twalletAddress.publicKey\n\t\t\t\t\t)\n\t\t\t  )[0]\n\t\t\t: walletAddress.publicKey;\n\n\t\tconst candyMachineAddress = candyMachine.id;\n\t\tconst remainingAccounts = [];\n\t\tconst signers = [mint];\n\t\tconst cleanupInstructions = [];\n\t\tconst instructions = [\n\t\t\tweb3.SystemProgram.createAccount({\n\t\t\t\tfromPubkey: walletAddress.publicKey,\n\t\t\t\tnewAccountPubkey: mint.publicKey,\n\t\t\t\tspace: MintLayout.span,\n\t\t\t\tlamports:\n\t\t\t\t\tawait candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n\t\t\t\t\t\tMintLayout.span\n\t\t\t\t\t),\n\t\t\t\tprogramId: TOKEN_PROGRAM_ID,\n\t\t\t}),\n\t\t\tToken.createInitMintInstruction(\n\t\t\t\tTOKEN_PROGRAM_ID,\n\t\t\t\tmint.publicKey,\n\t\t\t\t0,\n\t\t\t\twalletAddress.publicKey,\n\t\t\t\twalletAddress.publicKey\n\t\t\t),\n\t\t\tcreateAssociatedTokenAccountInstruction(\n\t\t\t\tuserTokenAccountAddress,\n\t\t\t\twalletAddress.publicKey,\n\t\t\t\twalletAddress.publicKey,\n\t\t\t\tmint.publicKey\n\t\t\t),\n\t\t\tToken.createMintToInstruction(\n\t\t\t\tTOKEN_PROGRAM_ID,\n\t\t\t\tmint.publicKey,\n\t\t\t\tuserTokenAccountAddress,\n\t\t\t\twalletAddress.publicKey,\n\t\t\t\t[],\n\t\t\t\t1\n\t\t\t),\n\t\t];\n\n\t\tif (candyMachine.state.gatekeeper) {\n\t\t\tremainingAccounts.push({\n\t\t\t\tpubkey: (\n\t\t\t\t\tawait getNetworkToken(\n\t\t\t\t\t\twalletAddress.publicKey,\n\t\t\t\t\t\tcandyMachine.state.gatekeeper.gatekeeperNetwork\n\t\t\t\t\t)\n\t\t\t\t)[0],\n\t\t\t\tisWritable: true,\n\t\t\t\tisSigner: false,\n\t\t\t});\n\t\t\tif (candyMachine.state.gatekeeper.expireOnUse) {\n\t\t\t\tremainingAccounts.push({\n\t\t\t\t\tpubkey: CIVIC,\n\t\t\t\t\tisWritable: false,\n\t\t\t\t\tisSigner: false,\n\t\t\t\t});\n\t\t\t\tremainingAccounts.push({\n\t\t\t\t\tpubkey: (\n\t\t\t\t\t\tawait getNetworkExpire(\n\t\t\t\t\t\t\tcandyMachine.state.gatekeeper.gatekeeperNetwork\n\t\t\t\t\t\t)\n\t\t\t\t\t)[0],\n\t\t\t\t\tisWritable: false,\n\t\t\t\t\tisSigner: false,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (candyMachine.state.whitelistMintSettings) {\n\t\t\tconst mint = new web3.PublicKey(\n\t\t\t\tcandyMachine.state.whitelistMintSettings.mint\n\t\t\t);\n\n\t\t\tconst whitelistToken = (\n\t\t\t\tawait getAtaForMint(mint, walletAddress.publicKey)\n\t\t\t)[0];\n\t\t\tremainingAccounts.push({\n\t\t\t\tpubkey: whitelistToken,\n\t\t\t\tisWritable: true,\n\t\t\t\tisSigner: false,\n\t\t\t});\n\n\t\t\tif (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n\t\t\t\tconst whitelistBurnAuthority = web3.Keypair.generate();\n\n\t\t\t\tremainingAccounts.push({\n\t\t\t\t\tpubkey: mint,\n\t\t\t\t\tisWritable: true,\n\t\t\t\t\tisSigner: false,\n\t\t\t\t});\n\t\t\t\tremainingAccounts.push({\n\t\t\t\t\tpubkey: whitelistBurnAuthority.publicKey,\n\t\t\t\t\tisWritable: false,\n\t\t\t\t\tisSigner: true,\n\t\t\t\t});\n\t\t\t\tsigners.push(whitelistBurnAuthority);\n\t\t\t\tconst exists =\n\t\t\t\t\tawait candyMachine.program.provider.connection.getAccountInfo(\n\t\t\t\t\t\twhitelistToken\n\t\t\t\t\t);\n\t\t\t\tif (exists) {\n\t\t\t\t\tinstructions.push(\n\t\t\t\t\t\tToken.createApproveInstruction(\n\t\t\t\t\t\t\tTOKEN_PROGRAM_ID,\n\t\t\t\t\t\t\twhitelistToken,\n\t\t\t\t\t\t\twhitelistBurnAuthority.publicKey,\n\t\t\t\t\t\t\twalletAddress.publicKey,\n\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tcleanupInstructions.push(\n\t\t\t\t\t\tToken.createRevokeInstruction(\n\t\t\t\t\t\t\tTOKEN_PROGRAM_ID,\n\t\t\t\t\t\t\twhitelistToken,\n\t\t\t\t\t\t\twalletAddress.publicKey,\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (candyMachine.state.tokenMint) {\n\t\t\tconst transferAuthority = web3.Keypair.generate();\n\n\t\t\tsigners.push(transferAuthority);\n\t\t\tremainingAccounts.push({\n\t\t\t\tpubkey: userPayingAccountAddress,\n\t\t\t\tisWritable: true,\n\t\t\t\tisSigner: false,\n\t\t\t});\n\t\t\tremainingAccounts.push({\n\t\t\t\tpubkey: transferAuthority.publicKey,\n\t\t\t\tisWritable: false,\n\t\t\t\tisSigner: true,\n\t\t\t});\n\n\t\t\tinstructions.push(\n\t\t\t\tToken.createApproveInstruction(\n\t\t\t\t\tTOKEN_PROGRAM_ID,\n\t\t\t\t\tuserPayingAccountAddress,\n\t\t\t\t\ttransferAuthority.publicKey,\n\t\t\t\t\twalletAddress.publicKey,\n\t\t\t\t\t[],\n\t\t\t\t\tcandyMachine.state.price.toNumber()\n\t\t\t\t)\n\t\t\t);\n\t\t\tcleanupInstructions.push(\n\t\t\t\tToken.createRevokeInstruction(\n\t\t\t\t\tTOKEN_PROGRAM_ID,\n\t\t\t\t\tuserPayingAccountAddress,\n\t\t\t\t\twalletAddress.publicKey,\n\t\t\t\t\t[]\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tconst metadataAddress = await getMetadata(mint.publicKey);\n\t\tconst masterEdition = await getMasterEdition(mint.publicKey);\n\n\t\tconst [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n\t\t\tcandyMachineAddress\n\t\t);\n\n\t\tinstructions.push(\n\t\t\tawait candyMachine.program.instruction.mintNft(creatorBump, {\n\t\t\t\taccounts: {\n\t\t\t\t\tcandyMachine: candyMachineAddress,\n\t\t\t\t\tcandyMachineCreator,\n\t\t\t\t\tpayer: walletAddress.publicKey,\n\t\t\t\t\twallet: candyMachine.state.treasury,\n\t\t\t\t\tmint: mint.publicKey,\n\t\t\t\t\tmetadata: metadataAddress,\n\t\t\t\t\tmasterEdition,\n\t\t\t\t\tmintAuthority: walletAddress.publicKey,\n\t\t\t\t\tupdateAuthority: walletAddress.publicKey,\n\t\t\t\t\ttokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n\t\t\t\t\ttokenProgram: TOKEN_PROGRAM_ID,\n\t\t\t\t\tsystemProgram: SystemProgram.programId,\n\t\t\t\t\trent: web3.SYSVAR_RENT_PUBKEY,\n\t\t\t\t\tclock: web3.SYSVAR_CLOCK_PUBKEY,\n\t\t\t\t\trecentBlockhashes: web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n\t\t\t\t\tinstructionSysvarAccount: web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n\t\t\t\t},\n\t\t\t\tremainingAccounts:\n\t\t\t\t\tremainingAccounts.length > 0\n\t\t\t\t\t\t? remainingAccounts\n\t\t\t\t\t\t: undefined,\n\t\t\t})\n\t\t);\n\n\t\ttry {\n\t\t\treturn (\n\t\t\t\tawait sendTransactions(\n\t\t\t\t\tcandyMachine.program.provider.connection,\n\t\t\t\t\tcandyMachine.program.provider.wallet,\n\t\t\t\t\t[instructions, cleanupInstructions],\n\t\t\t\t\t[signers, []]\n\t\t\t\t)\n\t\t\t).txs.map((t) => t.txid);\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t}\n\t\treturn [];\n\t};\n\n\treturn (\n\t\tcandyMachine && (\n\t\t\t<div className=\"machine-container\">\n\t\t\t\t<p>{`Drop Date: ${candyMachine.state.goLiveDateTimeString}`}</p>\n\t\t\t\t<p>{`Items Minted: ${candyMachine.state.itemsRedeemed} / ${candyMachine.state.itemsAvailable}`}</p>\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"cta-button mint-button\"\n\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\tmintToken().then(() =>\n\t\t\t\t\t\t\talert(\n\t\t\t\t\t\t\t\t\"Your NFT has been minted! Check your Phantom wallet\"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t\tMint NFT\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t)\n\t);\n};\n\nexport default CandyMachine;\n","import { Transaction } from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\nexport const getErrorForTransaction = async (\n  connection,\n  txid\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\n\nexport async function sendTransactionsWithManualRetry(\n  connection,\n  wallet,\n  instructions,\n  signers,\n){\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          'StopOnFailure',\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection,\n  wallet,\n  instructionSet,\n  signersSet,\n  sequenceType = 'Parallel',\n  commitment = 'singleGossip',\n  successCallback = (txid, ind) => {},\n  failCallback = (txid, ind) => false,\n  block,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns= [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch(reason => {\n        failCallback(signedTxns[i], i);\n        if (sequenceType === 'StopOnFailure') {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== 'Parallel') {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          // Return the txn we failed on by index\n          return {\n            number: breakEarlyObject.i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== 'Parallel') {\n    await Promise.all(pendingTxns);\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection,\n  wallet,\n  instructions,\n  signers,\n  awaitConfirmation = true,\n  commitment = 'singleGossip',\n  includesFeePayer = false,\n  block,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection,\n  wallet,\n  instructions,\n  signers,\n  commitment = 'singleGossip',\n  includesFeePayer = false,\n  block,\n  beforeSend,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection,\n  transaction,\n  commitment,\n) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid,\n  timeout,\n  connection,\n  commitment = 'recent',\n  queryStatus = false,\n){\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","export default __webpack_public_path__ + \"static/media/twitter-logo.d89d9a86.svg\";","import { WalletError } from \"@solana/wallet-adapter-base\";\nimport React, { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport twitterLogo from \"./assets/twitter-logo.svg\";\nimport CandyMachine from \"./CandyMachine\";\n\n// Constants\nconst TWITTER_HANDLE = \"texaglo_techno\";\nconst TWITTER_LINK = `https://twitter.com/${TWITTER_HANDLE}`;\n\nconst App = () => {\n\tconst [walletAddress, setWalletAddress] = useState(null);\n\tconst checkIfWalletIsConnected = async () => {\n\t\ttry {\n\t\t\tconst { solana } = window;\n\t\t\tif (solana) {\n\t\t\t\tif (solana.isPhantom) {\n\t\t\t\t\tconsole.log(\"Phantom wallet found!\");\n\t\t\t\t\tconst response = await solana.connect({\n\t\t\t\t\t\tonlyIfTrusted: true,\n\t\t\t\t\t});\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\"Connected with Public Key:\",\n\t\t\t\t\t\tresponse.publicKey.toString()\n\t\t\t\t\t);\n\t\t\t\t\tsetWalletAddress(response.publicKey.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\talert(\"Solana object not found! Get a Phantom Wallet!\");\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\t};\n\tconst connectWallet = async () => {\n\t\tconst { solana } = window;\n\t\tif (solana) {\n\t\t\tconst response = await solana.connect();\n\t\t\tconsole.log(\n\t\t\t\t\"Connected with Public Key:\",\n\t\t\t\tresponse.publicKey.toString()\n\t\t\t);\n\t\t\tsetWalletAddress(response.publicKey.toString());\n\t\t}\n\t};\n\n\tconst renderNotConnectedContainer = () => (\n\t\t<button\n\t\t\tclassName=\"\"\n\t\t\tonClick={connectWallet}\n\t\t>\n\t\t\t Mint\n\t\t</button>\n\t);\n\tuseEffect(() => {\n\t\tconst onLoad = async () => {\n\t\t\tawait checkIfWalletIsConnected();\n\t\t};\n\t\twindow.addEventListener(\"load\", onLoad);\n\t\treturn () => window.removeEventListener(\"load\", onLoad);\n\t}, []);\n\treturn (\n\t\t\n\t\t\n\t\t\t<div className=\"container\">\n\t\t\t\n\t\t\t\t\t{!walletAddress && renderNotConnectedContainer()}\n\t\t\t\t\n\t\t\t\t{walletAddress && (\n\t\t\t\t\t<CandyMachine walletAddress={window.solana} />\n\t\t\t\t)}\n\t\t\t\t<div className=\"footer-container\">\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\n\t);\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","import { web3 } from '@project-serum/anchor';\nimport * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\n// CLI Properties Given to us\nconst candyMachineProgram = new web3.PublicKey(\n  'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ'\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'\n);\n\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new web3.PublicKey(\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\n);\n\nconst CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nconst toDate = (value) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nconst formatNumber = {\n  format: (val) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nconst getAtaForMint = async (mint, buyer)=> {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nconst getNetworkExpire = async (gatekeeperNetwork) => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nconst getNetworkToken = async (wallet, gatekeeperNetwork) => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nfunction createAssociatedTokenAccountInstruction(\n  associatedTokenAddress,\n  payer,\n  walletAddress,\n  splTokenMintAddress,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n\nexport {\n  candyMachineProgram,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  CIVIC,\n  toDate,\n  formatNumber,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  createAssociatedTokenAccountInstruction,\n};\n"],"sourceRoot":""}